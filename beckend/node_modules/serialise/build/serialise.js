"use strict";
const customConstructors = {};
function serialisable(constructor) {
    if (customConstructors[constructor.name] != undefined) {
        throw new Error(`There is already a registered constructor called ${constructor.name}.`);
    }
    customConstructors[constructor.name] = constructor;
}
exports.serialisable = serialisable;
function serialise(x) {
    const type = getType(x);
    switch (type) {
        case KnownType.object:
            return serialiseObject(x);
        case KnownType.number:
            return x;
        case KnownType.string:
            return x;
        case KnownType.function:
            throw new Error('tried to serialise a function!');
        case KnownType.array:
            return x.map(serialise);
        case KnownType.null:
            return null;
        case KnownType.undefined:
            return serialiseUndefined();
        case KnownType.boolean:
            return x;
        default:
            const xx = type;
    }
}
exports.serialise = serialise;
const undefinedTypeStr = '__undefined__';
function serialiseUndefined() {
    return { cName: undefinedTypeStr, data: {} };
}
function serialiseLiteral(x, baseConstructor) {
    let propertyNames = Object.getOwnPropertyNames(x);
    const properties = {};
    const serialised = {};
    if (baseConstructor) {
        const deserialised = new baseConstructor.constructor(baseConstructor.serialised);
        propertyNames = propertyNames.filter((propName) => !deserialised.hasOwnProperty(propName));
    }
    for (let propName of propertyNames) {
        const descriptor = Object.getOwnPropertyDescriptor(x, propName);
        serialised[propName] = {
            v: serialise(descriptor.value),
            w: descriptor.writable,
            e: descriptor.enumerable,
            c: descriptor.configurable
        };
    }
    ;
    return serialised;
}
;
const n = Number;
const specialConstructors = [
    { constructor: Number, serialise: (x) => x.valueOf() },
    { constructor: String, serialise: (x) => x.valueOf() },
    { constructor: Date, serialise: (x) => x.getTime() },
    { constructor: Boolean, serialise: (x) => x.valueOf() }
];
function getWrappedPrimitive(constructor, x) {
    const parentConstructor = specialConstructors
        .find((sc) => sc.constructor.isPrototypeOf(constructor) || sc.constructor === constructor);
    if (parentConstructor) {
        return { constructor: parentConstructor.constructor, serialised: parentConstructor.serialise(x) };
    }
    return undefined;
}
function serialiseObject(x) {
    if (x.constructor === Object) {
        return {
            cName: 'Object',
            data: serialiseLiteral(x)
        };
    }
    else {
        if (!x.constructor.name) {
            throw new Error('missing constructor name!');
        }
        const constructor = x.constructor;
        const primitiveValue = getWrappedPrimitive(constructor, x);
        const returnValue = {
            cName: constructor.name,
            data: serialiseLiteral(x, primitiveValue)
        };
        if (primitiveValue) {
            returnValue.value = primitiveValue.serialised;
        }
        return returnValue;
    }
}
var KnownType;
(function (KnownType) {
    KnownType[KnownType["object"] = 0] = "object";
    KnownType[KnownType["number"] = 1] = "number";
    KnownType[KnownType["string"] = 2] = "string";
    KnownType[KnownType["function"] = 3] = "function";
    KnownType[KnownType["array"] = 4] = "array";
    KnownType[KnownType["boolean"] = 5] = "boolean";
    KnownType[KnownType["null"] = 6] = "null";
    KnownType[KnownType["undefined"] = 7] = "undefined";
})(KnownType || (KnownType = {}));
function getType(t) {
    const type = typeof t;
    switch (type) {
        case 'object':
            if (t == null) {
                return KnownType.null;
            }
            if (Array.isArray(t)) {
                return KnownType.array;
            }
            return KnownType.object;
        case 'number':
            return KnownType.number;
        case 'string':
            return KnownType.string;
        case 'function':
            return KnownType.function;
        case 'undefined':
            return KnownType.undefined;
        case 'boolean':
            return KnownType.boolean;
        default:
            throw new Error('unknown type: ' + type);
    }
}
function getTypeOfSerialised(t) {
    const rawType = getType(t);
    if (rawType == KnownType.object) {
        if (!t.cName) {
            console.error(t);
            throw new Error('got a raw object (missing cName). We can only deserialise our own object format');
        }
        if (t.cName == undefinedTypeStr) {
            return KnownType.undefined;
        }
    }
    return rawType;
}
function deserialise(x) {
    const type = getTypeOfSerialised(x);
    switch (type) {
        case KnownType.object:
            return deserialiseObject(x);
        case KnownType.number:
            return x;
        case KnownType.string:
            return x;
        case KnownType.boolean:
            return x;
        case KnownType.function:
            // I ain't even mad.
            return x;
        case KnownType.undefined:
            return undefined;
        case KnownType.null:
            return null;
        case KnownType.array:
            return x.map(deserialise);
        default:
            const xx = type;
    }
}
exports.deserialise = deserialise;
function deserialiseObject(o) {
    switch (o.cName) {
        case 'Number':
            return deserialiseObjectWithConstructor(Number, o);
        case 'String':
            return deserialiseObjectWithConstructor(String, o);
        case 'Date':
            return deserialiseObjectWithConstructor(Date, o);
        case 'Boolean':
            return deserialiseObjectWithConstructor(Boolean, o);
        case 'Object':
            return deserialiseObjectWithConstructor(Object, o);
        default:
            const constructor = customConstructors[o.cName];
            if (!constructor) {
                throw new Error('unknown constructor encountered with deserializing: ' + o.cName);
            }
            return deserialiseObjectWithConstructor(constructor, o);
    }
}
function deserialisationConstructor(o, constructor) {
    function newConstructor(arg) {
        const propertyNames = Object.getOwnPropertyNames(o.data);
        const properties = {};
        for (let newProp of propertyNames) {
            properties[newProp] = {
                value: deserialise(o.data[newProp].v),
                enumerable: o.data[newProp].e,
                configurable: o.data[newProp].c,
                writable: o.data[newProp].w
            };
        }
        Object.defineProperties(this, properties);
    }
    newConstructor.prototype = constructor.prototype;
    return newConstructor;
}
function deserialiseObjectWithConstructor(constructor, o) {
    let specialConstructor = undefined;
    if (o.value) {
        const sc = specialConstructors.find((c) => (c.constructor.isPrototypeOf(constructor) || c.constructor == constructor));
        specialConstructor = (sc) ? sc.constructor : undefined;
    }
    if (specialConstructor) {
        const d = Reflect.construct(specialConstructor, [o.value], constructor);
        deserialisationConstructor(o, constructor).call(d);
        return d;
    }
    else {
        return new (deserialisationConstructor(o, constructor))();
    }
}
